import numpy as np
import scipy
import time
import sched
import random
# to calculate the ballistics of a target, two samples is the minimum required for a triangle to be created

# simple example assumes a sonar image (probably want to generalize this to radar or image recognition)
class target_loc():
  # this class controls the 3D position and recording of radar data
  def __init__(self, phi, theta, r, time_spot):
    self.phi = phi
    self.theta = theta
    self.r = r
    self.time_spot = time_spot
  def tell(self):
    return (f"Phi: {self.phi}  " + f"Theta: {self.theta} " + f"Rho: {self.r}")

def target_radar_sight(return_data):
  # need a function that captures a location of the target
  time = time.time()
  return phi, theta, r, time

# code to generate random vector of target
# self, phi, theta, r, time_spot)
def generate_random_vector(max_distance, speed, seed):
  # this generates a simulation of the radar data given parameters
  # this program is entirely from the POV of the launch system in terms of phi, theta, distance, and speed
  if seed != 0:
    v_rand = random.Random(seed)
  else:
    v_rand = random.Random()
  # to test, a random generator instance is created and a seed is provded
  #im switching the generation of the vector to begin in cartestian to avoid messing this up again 
  # so only one data point is going to get generated by generate_random_vector
  phi = v_rand.randrange(0,8) * (np.pi / 2) / 10 # bounds of phi are 0 to pi / 2
  theta = v_rand.randrange(-10,10) * (np.pi / 2) / 10 # important to note that the bounds of theta are - pi/2 to pi/2
  first_data = target_loc(phi = phi, r = max_distance, theta = theta, time_spot = time.time())
  return first_data
  
def calculate_trajectory_target(first_data):
  # this data takes two recording of target data, calculates the derivatives
  # and converts the data from spherical to cartesian coordinates for easy of calculation 

  x_one = (first_data.r) * (np.cos(first_data.theta)) * (np.sin(first_data.phi))
  y_one = (first_data.r) * (np.sin(first_data.theta)) * (np.sin(first_data.phi))
  z_one = (first_data.r) * (np.cos(first_data.phi))

  # x_two = (second_data.r) * (np.cos(second_data.theta)) * (np.sin(second_data.phi))
  # y_two = (second_data.r) * (np.sin(second_data.theta)) * (np.sin(second_data.phi))
  # z_two = (second_data.r) * (np.cos(second_data.phi))

  x_two = x_one + random.random()
  y_two = y_one + random.random()
  z_two = z_one + random.random()
  
  xyz_one = [x_one,y_one, z_one]
  xyz_two  = [x_two, y_two, z_two]

  #deltaT = second_data.time_spot - first_data.time_spot 
  deltaT = 1
  deltaX = (x_two - x_one) / deltaT
  deltaY = (y_two - y_one) / deltaT
  deltaZ = (z_two - z_one) / deltaT

  deltaXYZ = [deltaX, deltaY, deltaZ]

  return [deltaT, deltaXYZ, xyz_one, xyz_two]

  data_one = target_loc(phi, theta, max_distance, 0)
  # need to update this to create more randomized velocity vectors for simulated targets 
  # as it currently exsits, the difference is small but it seems that small changes can cause radical differences in the spherical coordinate system
  
  data_two = target_loc(phi - .01,theta + 0.01, max_distance + 1, 0.1)

  return data_one

def generate_parabolic_vector(max_distance):
  # only the intial vector is supplied by this, the actual course needs to be simulated by a differential equation solver
  # assuming launcher sytem is located at (0,0,0)

  # should be noted that though generated_random_vector uses phi and theta in terms of the launch system,
  # the phi and theta referenced here are from the perspective of the initial site
  
  # note that this random angle has nothing to do with theta or phi, it is just a simple way of generating a set of x and y coordinates
  random_ground_angle = random.randrange(-10,10, 1) * (np.pi / 2) / 10
  z = 0
  y = max_distance * np.sin(random_angle)
  x = max_distance * np.cos(random_angle)

  # i want this to be mortar like, so phi needs to be quite large, theta probably should be towards (0,0,0) with some deviation
  phi = random.randrange(3,10, 1) * (np.pi / 2) / 10 # bounds of phi are 0 to pi / 2
  # to make a theta that is pointed somewhat towards origin, with a little deviation
  theta = np.tan(y/x) + (random.randrange(-10,10)/50)
  
  v_naught = 2
  initial_xyz = [x,y,z]
  
  return [initial_xyz, v_naught, phi, theta]
